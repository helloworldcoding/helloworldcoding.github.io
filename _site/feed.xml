<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-03-15T11:39:43+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hello world, Let’s Coding!</title><subtitle>Keeping looking,don't settle.</subtitle><entry><title type="html">generate a random number</title><link href="http://localhost:4000/random-number/" rel="alternate" type="text/html" title="generate a random number" /><published>2019-03-09T00:00:00+08:00</published><updated>2019-03-09T00:00:00+08:00</updated><id>http://localhost:4000/random-number</id><content type="html" xml:base="http://localhost:4000/random-number/">&lt;h1 id=&quot;随机数定义&quot;&gt;随机数定义&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据密码学原理，随机数的随机性检验可以分为三个标准：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.统计学伪随机性。
	统计学伪随机性指的是在给定的随机比特流样本中，1的数量大致等于0的数量，同理，“10”“01”“00”“11”四者数量大致相等。
	类似的标准被称为统计学随机性。满足这类要求的数字在人类“一眼看上去”是随机的。
2.密码学安全伪随机性。
	其定义为，给定随机样本的一部分和随机算法，不能有效的演算出随机样本的剩余部分。
3.真随机性。
	其定义为随机样本不可重现。实际上只要给定边界条件，真随机数并不存在。
	可是如果产生一个真随机数样本的边界条件十分复杂且难以捕捉（比如计算机当地的本底辐射波动值），可以认为用这个方法演算出来了真随机数。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;相应的，随机数也分为三类：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;伪随机数：满足第一个条件的随机数。&lt;/li&gt;
  &lt;li&gt;密码学安全的伪随机数：同时满足前两个条件的随机数。可以通过密码学安全伪随机数生成器计算得出。&lt;/li&gt;
  &lt;li&gt;真随机数：同时满足三个条件的随机数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;生成伪随机数算法&quot;&gt;生成伪随机数算法&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;伪随机数生成算法，也叫伪随机数生成器(Pseudo Random Number Generator，简称 PRNG)&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;br /&gt;
伪随机数序列，其实是确定的，只是看上去随机。比如在线性同余法中，当第一数确定后，
后续的值也就确定了。&lt;br /&gt;
生成n个随机数 \(
		x_1, x_2, …,  x_n
		\)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以使用一个 4 元组\( (Q, \sigma, \Sigma, f)\) 定义一个伪随机数生成算法，
其中:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\(  Q  是有限状态集合， \)&lt;/li&gt;
  &lt;li&gt;\(\sigma\) 为状态转移函数，&lt;/li&gt;
  &lt;li&gt;\(\Sigma\) 是有限输出集合，&lt;/li&gt;
  &lt;li&gt;\(f  是从 Q 到 \Sigma 的单射。\) &lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当需要一个伪随机数序列时，设定初始状态 \( q_0 \in Q \) ，每一次输出都由如下两个过程组成&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\( q_{n} = \sigma(q_{n-1}) \)&lt;/li&gt;
  &lt;li&gt;\( output_n = f(q_n), output_n \in \Sigma \)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;linear-congruential-generator线性同余法&quot;&gt;Linear congruential generator(线性同余法)&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_n = (ax_{n-1} + b)mod(m)&lt;/script&gt;

&lt;ol&gt;
  &lt;li&gt;a是乘数，b为增量，m为模数,\(x_0\)是种子数&lt;/li&gt;
  &lt;li&gt;一般而言，m是2的高次冪(\(2^{32}或2^{64}\)), \(0&amp;lt;a&amp;lt;m,0&amp;lt;=b&amp;lt;m,0&amp;lt;x_0&amp;lt;m\)&lt;/li&gt;
  &lt;li&gt;一般选取：\( 
         a=4p+1, b=2q+1,其中p,q是正整数
     \) &lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;m越大，序列的周期越长, a和b越大产生的伪随机数越均匀&lt;/li&gt;
  &lt;li&gt;a和m互质，产生的随机数效果比不互质好&lt;/li&gt;
  &lt;li&gt;LCG不能用于随机数要求高的场合，不能用于加密应用。&lt;/li&gt;
  &lt;li&gt;有些场合LCG有很好的应用，例如内存很紧张的嵌入式中，电子游戏控制台用的小整数，使用高位可以胜任。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rand = 1
def Lcg():
	a = 69069
	b = 1
	m = 1&amp;lt;&amp;lt;22
	global rand
	rand = (a * rand + b) %m
	return rand

	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;平法取中法&quot;&gt;平法取中法&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;1964年由冯.诺依曼提出。基本思路：将数列中\(x_i\)(假设有m位)平方，取得到2m位数(不足2m位，在最高位前面补0)
 取正中间m位数字，作为\(x_{i+1}\),由此产生一个伪随即数列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_{i+1} =  (x_i^2 * 10^{-m/2}) mod (10^{m/2})&lt;/script&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rand = 1
def middle_square():
	global rand
	m = 16
	rand = rand ** 2
	rand = (rand // 10**8) % 10**8
	return rand
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;blum-blum-shubbbs生成器&quot;&gt;Blum Blum Shub(BBS生成器)&lt;/h3&gt;

&lt;h3 id=&quot;mersenne-twister梅森旋转算法&quot;&gt;Mersenne twister(梅森旋转算法)&lt;/h3&gt;

&lt;h4 id=&quot;参考资料&quot;&gt;参考资料&lt;/h4&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;https://zhuanlan.zhihu.com/p/33903430 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;https://www.cnblogs.com/forget406/p/5294143.html &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><category term="random number" /><category term="python" /><summary type="html">随机数定义</summary></entry><entry><title type="html">My tmux config</title><link href="http://localhost:4000/tmux-note/" rel="alternate" type="text/html" title="My tmux config" /><published>2019-03-08T00:00:00+08:00</published><updated>2019-03-08T00:00:00+08:00</updated><id>http://localhost:4000/tmux-note</id><content type="html" xml:base="http://localhost:4000/tmux-note/">&lt;h4 id=&quot;窗口window和分区span快速切换&quot;&gt;窗口(window)和分区span快速切换&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bind-key num
在配置文件中加入`bind-key C-w last-window`就可以通过bind-key Ctrl+w来切换上次和当前的window了

`bind-key C-a last-span`，就可以通过bind-key Ctrl+a来切换上次和和当前的span
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="tmux" /><summary type="html">窗口(window)和分区span快速切换</summary></entry><entry><title type="html">My tour of golang</title><link href="http://localhost:4000/golang-basic/" rel="alternate" type="text/html" title="My tour of golang" /><published>2019-03-07T00:00:00+08:00</published><updated>2019-03-07T00:00:00+08:00</updated><id>http://localhost:4000/golang-basic</id><content type="html" xml:base="http://localhost:4000/golang-basic/">&lt;h4 id=&quot;basic-types&quot;&gt;Basic types&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;bool   默认值false&lt;/li&gt;
  &lt;li&gt;string 默认值””&lt;/li&gt;
  &lt;li&gt;int  int8 int16 int32 int64 默认值0&lt;/li&gt;
  &lt;li&gt;uint uint8 uint16 uint32 uint64 uintptr&lt;/li&gt;
  &lt;li&gt;byte // int8的别名&lt;/li&gt;
  &lt;li&gt;rune // int32的别名,代表unicode值&lt;/li&gt;
  &lt;li&gt;float32 float64 默认值0&lt;/li&gt;
  &lt;li&gt;complex64 complex128&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;类型转换&quot;&gt;类型转换&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;T(v) 显示类型转换，如int(12.4),string(11244)
    &lt;ul&gt;
      &lt;li&gt;不过整型转为string是按照ascii码或unicode码转为对应的字符，所以有可能得到乱码&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;原类型\转化后&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;bool&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;int&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;float&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;string&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;complex&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;bool&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;int&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;float&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;string&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;complex&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;variables-with-initializers变量和初始化&quot;&gt;Variables with initializers(变量和初始化)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 再函数内部以下三种写法都一样
var i,j int = 1, 3  // 全局可以用
var i, j = 1,3     // 全局可以用
i,j := 1,3 // 只能在函数体内部使用
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="golang" /><summary type="html">Basic types</summary></entry><entry><title type="html">Save Chinese characters in csv files with Python3</title><link href="http://localhost:4000/python3-save-chinese-characters-to-csv-file/" rel="alternate" type="text/html" title="Save  Chinese characters in csv files with Python3" /><published>2019-03-07T00:00:00+08:00</published><updated>2019-03-07T00:00:00+08:00</updated><id>http://localhost:4000/python3-save-chinese-characters-to-csv-file</id><content type="html" xml:base="http://localhost:4000/python3-save-chinese-characters-to-csv-file/">&lt;h1 id=&quot;导出一些数据给运营同学&quot;&gt;导出一些数据给运营同学&lt;/h1&gt;
&lt;h3 id=&quot;几点要求&quot;&gt;几点要求&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;一个脚本搞定，尽可能少地依赖其他包&lt;/li&gt;
  &lt;li&gt;可以用windows下的excel打开,中文不乱码&lt;/li&gt;
  &lt;li&gt;可以是csv文件，也可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;\t&lt;/code&gt;分割，生成xls文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;excel的坑&quot;&gt;excel的坑&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;在程序中能够正常输出中文，但是导出到文件后使用excel打开是出现中文乱码
因为excel能够正确识别用gb2312、gbk、gb18030或utf_8 with BOM 编码的中文，
如果是utf_8 no BOM编码的中文文件，excel打开会乱码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;代码如下&quot;&gt;代码如下：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;#!/usr/bin/python3
#coding:utf-8
import pymysql
import json

try:
    db = pymysql.connect(&quot;localhost&quot;,&quot;usrname&quot;,&quot;password&quot;,&quot;dbname&quot;,4040)
    cursor = db.cursor()
    sql = &quot;select org_code,command_return from upgrade_log where upgrade_id=1060 and stage_id=68&quot;
    cursor.execute(sql)
    # 关键是设置encoding=&quot;utf_8_sig&quot;,这样excel打开才不会出现中文乱码
    # 这样生成的文件就是有BOM头，excel才能正常处理中文
    fh = open(&quot;400.csv&quot;,&quot;w&quot;,encoding=&quot;utf_8_sig&quot;) 
    for row in cursor:
        org_code = row[0]
        info =json.loads(row[1]) # row[1]是一段json
        if len(info[2:]) &amp;gt; 0:
            for item in info[2:]:
                line = item.replace(&quot;\t&quot;,',')
                if line[-4:] != &quot;NULL&quot;:
                    line = line+&quot;, &quot;
                line = org_code+&quot;,&quot;+line +&quot;\n&quot;
                fh.write(line)
        else:
            print(org_code)

        
except Exception as err:
    print(err)

fh.close()
cursor.close()
db.close()
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="csv" /><category term="中文乱码" /><category term="python3" /><category term="utf-8" /><category term="utf-8" /><summary type="html">导出一些数据给运营同学 几点要求</summary></entry><entry><title type="html">dbext an awesome database client</title><link href="http://localhost:4000/dbext-vim-db-explorer/" rel="alternate" type="text/html" title="dbext an awesome database client" /><published>2019-02-19T00:00:00+08:00</published><updated>2019-02-19T00:00:00+08:00</updated><id>http://localhost:4000/dbext-vim-db-explorer</id><content type="html" xml:base="http://localhost:4000/dbext-vim-db-explorer/">&lt;h1 id=&quot;可能是最适合开发的数据库客户端&quot;&gt;可能是最适合开发的数据库客户端&lt;/h1&gt;

&lt;h4 id=&quot;支持的数据库类型&quot;&gt;支持的数据库类型:&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SAP Sybase SQL Anywhere (SA/ASA)
SAP Sybase IQ
SAP Sybase Adaptive Server Enterprise (ASE)
SAP HANA
SAP Sybase UltraLite (UL)
Oracle
Oracle RDB
SQL Server
MySQL
PostgreSQL
DB2
Firebird
Ingres
Interbase
SQLite
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;本文以MySQL为例，介绍一下该插件的功能。&lt;/p&gt;

&lt;h3 id=&quot;安装配置&quot;&gt;安装&amp;amp;配置&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Lets test the connection, run the following command (Note the capital S): &amp;gt;
`:Select * from customer`
Select, Update, Insert, Delete, Call, Drop, Alter, Create
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;功能介绍&quot;&gt;功能介绍&lt;/h3&gt;

&lt;h4 id=&quot;connect&quot;&gt;connect&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;使用快捷键 ：`&amp;lt;leader&amp;gt;sbp` leader键默认是`\`,  sbp(sql buffer prompt)
使用ex命令：`:DBPromptForBufferParameters`
然后选择要连接的数据库类型
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;execute&quot;&gt;execute&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;把光标置于sql语句中的任意位置（sql语句是一行）
`&amp;lt;leader&amp;gt;sel`  sql execute line

执行多行sql
`&amp;lt;leader&amp;gt;se`  sql execute 
`:DBExecSQLUnderCursor`

执行选中的sql
`:DBExecVisualSQL`
&amp;lt;leader&amp;gt;se  和多行执行一样

从表中查选,光标在表名称的单词上
`&amp;lt;leader&amp;gt;st`  sql table
`:DBSelectFromTable`
执行的sql是：select * from table_name

带条件的查询
`&amp;lt;leader&amp;gt;stw`
`:DBSelectFromTableWithWhere`
会提示你输入where条件， 比如 id &amp;gt; 1 and name like &quot;zhangsan&quot;
执行的sql：select * from table_name where id &amp;gt; 1 and name like &quot;zhangsan&quot;

等待输入表名查询
`&amp;lt;leader&amp;gt;sta`
`:DBSelectFromTableAskName`
会提示你输入你要查询的表名

高亮选择表名查询
`&amp;lt;leader&amp;gt;st`
`:'&amp;lt;,'&amp;gt;DBSelectFromTable`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;describing-objects&quot;&gt;Describing objects&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;表结构
`:DBDescribeTable`
`\sdt` sql describe table

存储过程procedures
`:DBDescribeProcedure`
`\dp`  d (describe) p (procedure)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="vim" /><category term="database" /><category term="navicat" /><summary type="html">可能是最适合开发的数据库客户端</summary></entry><entry><title type="html">Vim delete swp&amp;amp;swo file</title><link href="http://localhost:4000/vimscript-delete-swp-swo-file/" rel="alternate" type="text/html" title="Vim delete swp&amp;swo file" /><published>2019-02-17T00:00:00+08:00</published><updated>2019-02-17T00:00:00+08:00</updated><id>http://localhost:4000/vimscript-delete-swp-swo-file</id><content type="html" xml:base="http://localhost:4000/vimscript-delete-swp-swo-file/">&lt;p&gt;写了一个小函数，来删除vim的swp和swo文件。&lt;/p&gt;

&lt;p&gt;在normal模式下，输入\ds就可以删除该文件对应的swp和swo文件。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot; 删除当前文件对应的swp和swo文件
function! DeleteSpaw()
	let l:fname = fnameescape(expand('%:t'))
	let l:swp = '.'.l:fname.'.swp'
	let l:swo = '.'.l:fname.'.swo'
	if CheckFile(l:swp)
		echom DeleteFile(l:swp) == 1 ? l:swp.' delete successfully' : l:swp.' delete faild '
	endif
	if CheckFile(l:swo)
		echom DeleteFile(l:swo) == 1 ? l:swo.' delete successfully' : l:swo.' delete faild '
	endif
endfunction

function! DeleteFile(filename)
	let l:del_result = delete(expand(a:filename))
	return l:del_result == 0 ? 1 : 0
endfunction

function! CheckFile(filename)
	&quot; 对于不可以读取的文件，换成glob
	if filereadable(expand(a:filename)) 
		return 1
	else
		return 0
	endif
endfunction

&quot; 调用删除swp,swo文件函数
nnoremap &amp;lt;leader&amp;gt;ds :call DeleteSpaw()&amp;lt;cr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;获取文件名expand(‘%:t’),参考&lt;code class=&quot;highlighter-rouge&quot;&gt;help filename-modifiers&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;文件相关的函数，&lt;code class=&quot;highlighter-rouge&quot;&gt;filereadable(), delete()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;函数内部对参数使用，a:param&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="vim" /><category term="swp" /><category term="swo" /><category term="delete" /><summary type="html">写了一个小函数，来删除vim的swp和swo文件。</summary></entry><entry><title type="html">Magic Regrex In Vimscript</title><link href="http://localhost:4000/Vimscript-Magic-Regrex/" rel="alternate" type="text/html" title="Magic Regrex In Vimscript" /><published>2019-01-31T00:00:00+08:00</published><updated>2019-01-31T00:00:00+08:00</updated><id>http://localhost:4000/Vimscript-Magic-Regrex</id><content type="html" xml:base="http://localhost:4000/Vimscript-Magic-Regrex/">&lt;h1 id=&quot;正则表达式&quot;&gt;正则表达式&lt;/h1&gt;

&lt;h3 id=&quot;magic&quot;&gt;Magic&lt;/h3&gt;
&lt;p&gt;{test&lt;a href=&quot;123&quot;&gt;123&lt;/a&gt;}&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Vim有&lt;strong&gt;四种&lt;/strong&gt;不同的解析正则表达式的模式！！！真让人蒙蔽。。。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="vim" /><category term="vimscript" /><category term="regrex" /><summary type="html">正则表达式</summary></entry><entry><title type="html">Nodejs Async Await</title><link href="http://localhost:4000/nodejs-async-await/" rel="alternate" type="text/html" title="Nodejs Async Await" /><published>2019-01-31T00:00:00+08:00</published><updated>2019-01-31T00:00:00+08:00</updated><id>http://localhost:4000/nodejs-async-await</id><content type="html" xml:base="http://localhost:4000/nodejs-async-await/"></content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Nodejs Promise</title><link href="http://localhost:4000/nodejs-promise/" rel="alternate" type="text/html" title="Nodejs Promise" /><published>2019-01-30T00:00:00+08:00</published><updated>2019-01-30T00:00:00+08:00</updated><id>http://localhost:4000/nodejs-promise</id><content type="html" xml:base="http://localhost:4000/nodejs-promise/"></content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">My nodejs note</title><link href="http://localhost:4000/nodejs-note/" rel="alternate" type="text/html" title="My nodejs note" /><published>2019-01-29T00:00:00+08:00</published><updated>2019-01-29T00:00:00+08:00</updated><id>http://localhost:4000/nodejs-note</id><content type="html" xml:base="http://localhost:4000/nodejs-note/">&lt;p&gt;Nodejs is just a kind of of js..^_^&lt;/p&gt;

&lt;h1 id=&quot;基本语法&quot;&gt;基本语法&lt;/h1&gt;

&lt;p&gt;pass&lt;/p&gt;

&lt;h1 id=&quot;工程相关&quot;&gt;工程相关&lt;/h1&gt;

&lt;h3 id=&quot;模块&quot;&gt;模块&lt;/h3&gt;

&lt;p&gt;在模块中，用require()方法来引入外部模块。用exports对象用于导出当前模块的方法或变量,只有导出的变量或方法才能被其他模块使用。就像是oop中的public。这点和erlang有点像，erlang是声明一个导出列表&lt;code&gt;-export([add/1,...])&lt;/code&gt;
在模块中，module对象，代表自身，exports也是module的一个属性.
在nodejs中，一个文件就是一个模块.(其他编程语言也差不多)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;require()的参数就是模块标识。参数可以是小驼峰命名的字符串(模块名?),
也可以是相对路径，或绝对路径。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;两种模块，Node提供的核心模块(fs,http,path…)，用户编写的称为文件模块。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模块加载，优先从缓存加载，核心模块加载，路径形式的模块，自定义模块(加载最慢，一种特殊的文件模块)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;自定义模块&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  文件内容：
  console.log(module.paths);
  node ./test.js,输出如下:
  [ '/home/wm/code/nodejs/one_night/node_modules',
    '/home/wm/code/nodejs/node_modules',
    '/home/wm/code/node_modules',
    '/home/wm/node_modules',
    '/home/node_modules',
    '/node_modules' ]
  node查找自定义模块的规则：
  当前文件目录的node_modules目录下查找
  父目录的node_modules目录
  ...
  直到根目录下的node_modules目录
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;引用了不同的模块，如果他们有相同的导出方法或属性。后面引用的模块会覆盖先引用的模块&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ./node_modules/demo.js内容:
  hello = function(){
      console.log(&quot;hello world&quot;);
  }
  exports.hello;

  ./node_modules/hi.js内容:
  hello = function(){
      console.log(&quot;hi world&quot;);
  }
  exports.hello;

  ./test.js内容如下:
  require('hi');
  require(&quot;demo&quot;);
  hello(); // 输出 hello world
  console.log(module.paths);
		
  require(&quot;demo&quot;);
  require('hi');
  hello(); // 输出 hi world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;文件扩展名.当标识符没有扩展名时 Node会按.js .json .node的顺序依次补充扩展名，以此尝试&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;目录分析和包&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  在node_modules/目录下的子目录，可以做成一个包，package
  前提是，这个目录下要有一个package.json文件，并且文件能通过JSON.parse()解析出描述对象。
  比如main属性，指定文件名进行定位。
  如果没有package.json文件，node会依次查找index.js index.json index.node

  ./test.js内容如下:
  require(&quot;mypackage&quot;);
  test(&quot;guogu0&quot;); // 输出 myname is guoguo

  在当前./node_modules/下发现了子目录./node_modules/mypackage/
  mypackage/目录下有package.json文件，内容如下
  {
      &quot;name&quot;:&quot;mypack&quot;,
      &quot;version&quot;: &quot;0.0.1&quot;,
      &quot;main&quot;: &quot;./src/bar.js&quot; // 先对package.json文件的路径
  }
  通过main属性可知，这个mypackage包 指定的是 ./node_modules/mypackage/src/bar.js文件
  该bar.js文件内容如下：
  test = function(name) {
      console.log(&quot;myname is &quot;+name);
  }
  exports.test = test;

  所以test.js在require(&quot;mypackage&quot;)的时候，其实是找到了一个目录，也就是一个包。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="nodjs" /><category term="tiny demo" /><summary type="html">Nodejs is just a kind of of js..^_^</summary></entry></feed>