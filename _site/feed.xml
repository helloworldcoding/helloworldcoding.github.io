<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-01-30T00:10:13+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hello world, Let’s Coding!</title><subtitle>Keeping looking,don't settle.</subtitle><entry><title type="html">Nodejs Async Await</title><link href="http://localhost:4000/nodejs-async-await/" rel="alternate" type="text/html" title="Nodejs Async Await" /><published>2019-01-31T00:00:00+08:00</published><updated>2019-01-31T00:00:00+08:00</updated><id>http://localhost:4000/nodejs-async-await</id><content type="html" xml:base="http://localhost:4000/nodejs-async-await/"></content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Nodejs Promise</title><link href="http://localhost:4000/nodejs-promise/" rel="alternate" type="text/html" title="Nodejs Promise" /><published>2019-01-30T00:00:00+08:00</published><updated>2019-01-30T00:00:00+08:00</updated><id>http://localhost:4000/nodejs-promise</id><content type="html" xml:base="http://localhost:4000/nodejs-promise/"></content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">My nodejs note</title><link href="http://localhost:4000/nodejs-note/" rel="alternate" type="text/html" title="My nodejs note" /><published>2019-01-29T00:00:00+08:00</published><updated>2019-01-29T00:00:00+08:00</updated><id>http://localhost:4000/nodejs-note</id><content type="html" xml:base="http://localhost:4000/nodejs-note/">&lt;p&gt;Nodejs is just a kind of of js..^_^&lt;/p&gt;

&lt;h1 id=&quot;基本语法&quot;&gt;基本语法&lt;/h1&gt;

&lt;p&gt;pass&lt;/p&gt;

&lt;h1 id=&quot;工程相关&quot;&gt;工程相关&lt;/h1&gt;

&lt;h3 id=&quot;模块&quot;&gt;模块&lt;/h3&gt;

&lt;p&gt;在模块中，用require()方法来引入外部模块。用exports对象用于导出当前模块的方法或变量,只有导出的变量或方法才能被其他模块使用。就像是oop中的public。这点和erlang有点像，erlang是声明一个导出列表&lt;code&gt;-export([add/1,...])&lt;/code&gt;
在模块中，module对象，代表自身，exports也是module的一个属性.
在nodejs中，一个文件就是一个模块.(其他编程语言也差不多)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;require()的参数就是模块标识。参数可以是小驼峰命名的字符串(模块名?),
也可以是相对路径，或绝对路径。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;两种模块，Node提供的核心模块(fs,http,path…)，用户编写的称为文件模块。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模块加载，优先从缓存加载，核心模块加载，路径形式的模块，自定义模块(加载最慢，一种特殊的文件模块)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;自定义模块&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  文件内容：
  console.log(module.paths);
  node ./test.js,输出如下:
  [ '/home/wm/code/nodejs/one_night/node_modules',
    '/home/wm/code/nodejs/node_modules',
    '/home/wm/code/node_modules',
    '/home/wm/node_modules',
    '/home/node_modules',
    '/node_modules' ]
  node查找自定义模块的规则：
  当前文件目录的node_modules目录下查找
  父目录的node_modules目录
  ...
  直到根目录下的node_modules目录
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;引用了不同的模块，如果他们有相同的导出方法或属性。后面引用的模块会覆盖先引用的模块&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ./node_modules/demo.js内容:
  hello = function(){
      console.log(&quot;hello world&quot;);
  }
  exports.hello;

  ./node_modules/hi.js内容:
  hello = function(){
      console.log(&quot;hi world&quot;);
  }
  exports.hello;

  ./test.js内容如下:
  require('hi');
  require(&quot;demo&quot;);
  hello(); // 输出 hello world
  console.log(module.paths);
		
  require(&quot;demo&quot;);
  require('hi');
  hello(); // 输出 hi world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;文件扩展名.当标识符没有扩展名时 Node会按.js .json .node的顺序依次补充扩展名，以此尝试&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;目录分析和包&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  在node_modules/目录下的子目录，可以做成一个包，package
  前提是，这个目录下要有一个package.json文件，并且文件能通过JSON.parse()解析出描述对象。
  比如main属性，指定文件名进行定位。
  如果没有package.json文件，node会依次查找index.js index.json index.node

  ./test.js内容如下:
  require(&quot;mypackage&quot;);
  test(&quot;guogu0&quot;); // 输出 myname is guoguo

  在当前./node_modules/下发现了子目录./node_modules/mypackage/
  mypackage/目录下有package.json文件，内容如下
  {
      &quot;name&quot;:&quot;mypack&quot;,
      &quot;version&quot;: &quot;0.0.1&quot;,
      &quot;main&quot;: &quot;./src/bar.js&quot; // 先对package.json文件的路径
  }
  通过main属性可知，这个mypackage包 指定的是 ./node_modules/mypackage/src/bar.js文件
  该bar.js文件内容如下：
  test = function(name) {
      console.log(&quot;myname is &quot;+name);
  }
  exports.test = test;

  所以test.js在require(&quot;mypackage&quot;)的时候，其实是找到了一个目录，也就是一个包。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="nodjs" /><category term="tiny demo" /><summary type="html">Nodejs is just a kind of of js..^_^</summary></entry><entry><title type="html">Execute &amp;amp; normal in Vimscript</title><link href="http://localhost:4000/vimscript-execute-normal/" rel="alternate" type="text/html" title="Execute &amp; normal in Vimscript" /><published>2019-01-28T00:00:00+08:00</published><updated>2019-01-28T00:00:00+08:00</updated><id>http://localhost:4000/vimscript-execute-normal</id><content type="html" xml:base="http://localhost:4000/vimscript-execute-normal/">&lt;h1 id=&quot;execute命令&quot;&gt;Execute命令&lt;/h1&gt;

&lt;p&gt;execute命令，把字符串当作vimscript命令来执行.&lt;/p&gt;

&lt;h4 id=&quot;基本用法&quot;&gt;基本用法&lt;/h4&gt;

&lt;p&gt;:exe[cute] {expr1} ..	
	把{expr1}当作一个Ex命令来执行，并返回结果。多个参数，用空格分隔。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;多个命令可以用| 连起来
:execute '!ls' | echom &quot;theend&quot; 

在execute后面的字符串中可以使用\&amp;lt;esc&amp;gt;这样的方式来使用\e,看上去跟明显
\e	escape &amp;lt;Esc&amp;gt;
\f	formfeed &amp;lt;FF&amp;gt;
\n	newline &amp;lt;NL&amp;gt;
\r	return &amp;lt;CR&amp;gt;
\t	tab &amp;lt;Tab&amp;gt;

当文件名中有特殊字符的时候，要小心了。
:execute &quot;e &quot;.fnameescape(filename) &quot; fnameescape()函数用在vim的命令中
:execute &quot;!ls &quot; . shellescape(filename, 1) &quot; shellescape()函数用在shell命令中

当要执行多行的命令时，用|来 执行得了,|要放在引号之内
:execute 'while i &amp;lt; 5 | echo i | let i = i + 1 | endwhile'

注释,|&quot;之后的是注释
execute &quot;echo 'foo'&quot; | &quot; this is a comment
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;normal命令&quot;&gt;Normal命令&lt;/h1&gt;

&lt;p&gt;normal 命令简单地接受一串键值并当作是在normal模式下输入的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:normal ggdd  &quot;删除第一行
:normal G &quot;一般情况下，这个会把光标移到最后一行。
&quot;但是如果用户设置映射呢?比如nnoremap G dd ,这个时候，就会变成删除了。。。。惊不惊喜？
:normal! G &quot;这样就能确保光标移到最后，即便用户设置了G的映射，映射也不会生效。

所以，在写vim脚本的时候，应该总是用normal!,因为你不确定用户在他的.vimrc文件中做了哪些映射

:normal! /foo&amp;lt;cr&amp;gt; &quot;这样不会起作用 ,这种情况，需要结合execute来进行

:execute &quot;normal! /foo\&amp;lt;cr&amp;gt;&quot; &quot; 这样就可以起到查找foo的作用了
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;转义字符&quot;&gt;转义字符&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;string&quot;		string constant		*expr-quote*

Note that double quotes are used.

A string constant accepts these special characters:
\...	three-digit octal number (e.g., &quot;\316&quot;)
\..	two-digit octal number (must be followed by non-digit)
\.	one-digit octal number (must be followed by non-digit)
\x..	byte specified with two hex numbers (e.g., &quot;\x1f&quot;)
\x.	byte specified with one hex number (must be followed by non-hex char)
\X..	same as \x..
\X.	same as \x.
\u....	character specified with up to 4 hex numbers, stored according to the
	current value of 'encoding' (e.g., &quot;\u02a4&quot;)
\U....	same as \u but allows up to 8 hex numbers.
\b	backspace &amp;lt;BS&amp;gt;
\e	escape &amp;lt;Esc&amp;gt;
\f	formfeed &amp;lt;FF&amp;gt;
\n	newline &amp;lt;NL&amp;gt;
\r	return &amp;lt;CR&amp;gt;
\t	tab &amp;lt;Tab&amp;gt;
\\	backslash
\&quot;	double quote
\&amp;lt;xxx&amp;gt;	Special key named &quot;xxx&quot;.  e.g. &quot;\&amp;lt;C-W&amp;gt;&quot; for CTRL-W.  This is for use
	in mappings, the 0x80 byte is escaped.
	To use the double quote character it must be escaped: &quot;&amp;lt;M-\&quot;&amp;gt;&quot;.
	Don't use &amp;lt;Char-xxxx&amp;gt; to get a utf-8 character, use \uxxxx as
	mentioned above.

Note that &quot;\xff&quot; is stored as the byte 255, which may be invalid in some
encodings.  Use &quot;\u00ff&quot; to store character 255 according to the current value
of 'encoding'.

Note that &quot;\000&quot; and &quot;\x00&quot; force the end of the string.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="execute" /><category term="normal" /><category term="vimscript" /><category term="vim" /><summary type="html">Execute命令</summary></entry><entry><title type="html">vimscript regex</title><link href="http://localhost:4000/vimscript-regex/" rel="alternate" type="text/html" title="vimscript regex" /><published>2019-01-28T00:00:00+08:00</published><updated>2019-01-28T00:00:00+08:00</updated><id>http://localhost:4000/vimscript-regex</id><content type="html" xml:base="http://localhost:4000/vimscript-regex/"></content><author><name></name></author><category term="vimscript" /><category term="regex" /><category term="vim" /><summary type="html"></summary></entry><entry><title type="html">Vimscript begin</title><link href="http://localhost:4000/vimscript-begin/" rel="alternate" type="text/html" title="Vimscript begin" /><published>2019-01-26T00:00:00+08:00</published><updated>2019-01-26T00:00:00+08:00</updated><id>http://localhost:4000/vimscript-begin</id><content type="html" xml:base="http://localhost:4000/vimscript-begin/">&lt;p&gt;既然把vimscript是一个脚本语言，那就会有脚本语言的一些共性，比如变量的定义,变量的类型，变量的作用域，分支循环结构,函数等等。&lt;/p&gt;

&lt;h1 id=&quot;变量&quot;&gt;变量&lt;/h1&gt;

&lt;h4 id=&quot;变量的定义&quot;&gt;变量的定义&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一般的变量定义&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;变量名规范: 字母、数字、下划线，并且不能以数字开头&lt;/p&gt;

        &lt;p&gt;:let foo = “bar”
  :let num = 32
  :echo foo num “ 显示foo和num
  :unlet foo “ 销毁一个变量
  以上好像看出vimscript是动态类型，其实,你们想错了。(党国的高官，怎么会有钱？)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置选项也是变量&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  比如，我要看配置选项textwidth的值
  :echo &amp;amp;textwidth &quot;需要在前面加上&amp;amp; ,这就告诉vim，你在引用这个选项;如果这个选项不存在，就会报错
  :set textwidth=80
  :echo textwidth &quot;直接输出，也会报错
      E121: Undefined variable: textwidth
      E15: Invalid expression: textwidth
  :echo &amp;amp;textwidth &quot;输出 80

  :set nowrap
  :echo &amp;amp;wrap &quot; 0
  :set wrap
  :echo &amp;amp;wrap &quot; 1
  在vimscript中0为false，非0值整数为true 

  可以用let来设置选项的值，并且let比set更灵活	
  :let &amp;amp;textwidth = &amp;amp;textwidth + 10
  :echo &amp;amp;textwidth &quot; 输出 90
  :set &amp;amp;textwidth = &amp;amp;textwidth + 10 &quot;set 只能给设置一个常量值
      E518: Unknown option: &amp;amp;textwidth = 

  本地选项，将某个选项作为变量来来设置它的本地值，而不是全局值,
  本地变量的前缀:  &amp;lt;code&amp;gt;l:&amp;lt;/code&amp;gt;
  :let &amp;amp;l:number = 0 &quot;只对当前buffer生效,当前buffer，行号消失
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寄存器变量&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  :let @a=&quot;hello!&quot;
  :echo @a &quot;输出 hello!
  :echo @&quot; &quot;输出无名寄存器的值
  :echo @/ &quot;输出，搜索寄存器的值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;b:变量前缀(只在当前buffer生效的变量)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  :let b:hello = &quot;world&quot;
  :echo b:hello &quot; 输出world
  切换到另一个buffer
  :echo b:hello 
      E121: Undefined variable: b:hello
      E15: Invalid expression: b:hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;help internal-variables&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;变量前缀&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;名称&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;b:&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;buffer-variable&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Local to the current buffer.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;w:&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;window-variable&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Local to the current window.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;t:&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;tabpage-variable&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Local to the current tab page.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;g:&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;global-variable&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Global.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;l:&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;local-variable&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Local to a function.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s:&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;script-variable&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Local to a |:source|’ed Vim script.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;a:&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;function-argument&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Function argument (only inside a function).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;v:&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;vim-variable&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Global, predefined by Vim.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;分支结构&quot;&gt;分支结构&lt;/h1&gt;
&lt;h3 id=&quot;条件语句&quot;&gt;条件语句&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;多行命令，写成一行。用管道符(|)来隔开命令&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  :echom &quot;foo&quot; | echom &quot;bar&quot;
  :if 1 | :echom &quot;one&quot; | :else | :echom &quot;not one&quot; | :endif &quot; 输出 one
  :if 0 | echom &quot;one&quot; | else | echom &quot;not one&quot; | endif &quot; 输出not one
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;if的用法&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;必要情况下(数学计算、条件表达式)，vim强制转换变量和字面量的类型。10+”20foo” 最后等于10+20 = 30&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;以数字开头的字符串会转化为数字，否则会转化为0&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  :echo 0+&quot;12.64ab&quot; &quot;输出12
  :echo 0+&quot;-12.34ab&quot; &quot;输出-12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;if判断时，非零整数为true，0为false&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let a = 3
  if a == 1
      echom &quot;one&quot;
  elseif  a == 2
      echom &quot;two&quot;
  else
      echom &quot;not one or two&quot;
  endif
  &quot;最后输出 not one or two

  if &quot;string&quot;  &quot;等价于 if 0
      echom &quot;zero&quot;
  endif

  if &quot;12Ab&quot; ==# &quot;12ab&quot;
      echom &quot;yeshi&quot;
  else
      echom &quot;no&quot;  &quot; 输出 no, 说明 ==# 没有进行强制转化
  endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;比较运算符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;大于,如 10 &amp;gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;lt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小于,如 1 &amp;lt; 10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;==&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;相等，如 10 == 11 ,”foo” == “bar”,会受用户设置noignorecase/ignorecase影响&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;==?&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符串比较，大小写不敏感(无论vim对大小写的设置是否敏感),”foo” ==? “FOO” is true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;==#&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符串比较，大小写敏感(无论vim对大小写的设置是否敏感),”foo” ==# “FOO” is false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;gt;#&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;大于， 区分大小写的比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;lt;#&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小于， 区分大小写的比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;gt;?&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;大于， 不区分大小写的比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;lt;?&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小于， 不区分大小写的比较&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;所以最好使用==#来比较字符串,统一自己的规范&lt;/p&gt;

&lt;h1 id=&quot;循环&quot;&gt;循环&lt;/h1&gt;

&lt;h4 id=&quot;for循环&quot;&gt;for循环&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;help for&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let c = 0
  for i in [1,2,3,4]
      let c += i
  endfor
  echom c

  for [lnum, col] in [[1, 3], [2, 5], [3, 8]]
     echo getline(lnum)[col]
  endfor
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;while循环&quot;&gt;while循环&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;help while&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let c = 1
  let total = 0 
  while c &amp;lt;= 4
      let total += c
      let c += 1
  ednwhile 函数 ====
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;没有作用域限制的vimscript函数必须以一个大写字母开头&quot;&gt;没有作用域限制的vimscript函数，必须以一个大写字母开头&lt;/h4&gt;

&lt;div class=&quot;language-vimscript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; Hello&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;echom&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;helloworld&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;endfunction&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; Hello&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; SayHi&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a:name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt;# &lt;span class=&quot;s2&quot;&gt;&quot;Mark&quot;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi,Mark&quot;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;endif&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;endfunction&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;echom&lt;/span&gt; SayHi&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &quot; 函数如果没有返回，默认是&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;&quot;可变参数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; Multiargs&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;echom&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a:0&lt;/span&gt; &quot;参数数量&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;可变参数的数量
	&lt;span class=&quot;k&quot;&gt;echom&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a:1&lt;/span&gt; &quot;第一个参数
	&lt;span class=&quot;k&quot;&gt;echom&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a:2&lt;/span&gt; &quot;第二个参数
&lt;span class=&quot;k&quot;&gt;endfunction&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&quot;可变参数和普通参数一起使用&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; Multiargs2&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;foo&lt;span class=&quot;p&quot;&gt;,...)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;echom&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a:0&lt;/span&gt; 
	&lt;span class=&quot;k&quot;&gt;echom&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a:foo&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;echom&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a:1&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;echom&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a:2&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; s &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a:000&lt;/span&gt; &quot;&lt;span class=&quot;nv&quot;&gt;a:000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;所有的可变参数
		&lt;span class=&quot;k&quot;&gt;echom&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;s
	&lt;span class=&quot;k&quot;&gt;endfor&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;endfunction&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; Multiargs2&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hh&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;jak&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;luc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
输出：
&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
hh
jak
luc
 jak
 luc
可见&lt;span class=&quot;nv&quot;&gt;a:0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;只是代表可变参数的数量

&lt;span class=&quot;c&quot;&gt;&quot;函数参数是只读的，不能在函数内部改变&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; Assign&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;foo&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a:foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Nope&quot;&lt;/span&gt;  
&lt;span class=&quot;k&quot;&gt;endfunction&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; Assign&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 会报错，如下：
E46&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; Cannot change &lt;span class=&quot;k&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;only&lt;/span&gt; variable &lt;span class=&quot;s2&quot;&gt;&quot;a:foo&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;&quot;function! 如果出现重复函数名，感叹号不会报错。&lt;/span&gt;
When &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; by this name already exists and &lt;span class=&quot;p&quot;&gt;[!]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt;
not used an error message &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; given&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;!&lt;/span&gt; Assign&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;suceess&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;endfunction&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;msg&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;code&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; Assign&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &quot;返回一个数组
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;数据类型&quot;&gt;数据类型&lt;/h1&gt;

&lt;h4 id=&quot;布尔&quot;&gt;布尔&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;0为false， 其他整数为true&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;数字&quot;&gt;数字&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;整数(Number,32位带符号整数(如果编译的时候+num64，就支持64位))&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  echom 100
  echom 0xff 0X1f  &quot; 0x或0X前缀的来指定16进制
  echom 010 017 &quot;0前缀，是八进制,8,15
  echom 019 &quot;因为它不是一个八进制，所以输出19
  echom 0b1010 &quot;0b前缀，是二进制 ,输出十进制10
  &quot;尽量避免使用八进制
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;浮点(Float)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  [-+]{N}.{M}
  [-+]{N}.{M}[eE][-+]{exp}
  N,M都是正整数，exp代表10的多少次方,exp也是一个正整数

  echo 12.0 &quot;12.0
  echo 5.45e+3 &quot; 5450.0
  echo 5.3453e9 &quot; 5.3453e9
  if 5.345e2 &amp;gt; 500  &quot; this is true
      echom &quot;biger&quot;
  endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;强制转换&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  echo 3/2 &quot;1
  echo 3.0/2 &quot;1.5 Number和Float混用时，会把Number转换为Float
  echo 1/3.0 &quot;0.33333,默认是6位小数的精度
  echo printf('%.15e',11/7.0)  &quot;1.571428571428571e+00
  echo printf('%.15e',atan(1)) &quot;7.853981633974483e-01
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;字符串&quot;&gt;字符串&lt;/h4&gt;

&lt;p&gt;用双引号或者单引号包围的字符。双引号会转义\n,\,&quot;等特殊字符，而单引号不会(除了’‘转义为’之外）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;连接(concatenation)用点号. 和php一样&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  echom &quot;hello &quot;.&quot;world&quot; &quot;helloworld&quot;
  echom 12.&quot;foo&quot; &quot;12foo
  echom 12.&quot;123&quot; &quot;12123
  echom 12.1. &quot;foo&quot; &quot;121foo
  echom 12.1.&quot;foo&quot; &quot;121foo
  浮点数连接字符串，报错：
  echom 12.1 .&quot;foo&quot; &quot;E806: using Float as a String E15: Invalid expression: 12.1 .&quot;foo&quot;
  echom 12.1 . &quot;foo&quot; &quot;E806: using Float as a String E15: Invalid expression: 12.1 .&quot;foo&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;特殊字符(双引号才能转义)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  help expr-quote
  echom &quot;foo \&quot;bar\&quot;&quot;   &quot;输出 foo &quot;bar&quot;
  echom &quot;a\nb&quot; &quot;输出 a^@b
  echo &quot;a\nb&quot; &quot;输出两行，a 和 b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符串字面量(除了’‘会转义为’,其他的原样输出)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  help literal-string
  echom '\n\\' &quot;输出\n\\
  echo '12''23' &quot;输出12'34
  echo '12''''23' &quot;输出12''34
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符串函数&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  字符串字节数量
  echom strlen(&quot;foo&quot;) &quot;3	
  echom strlen(&quot;我的1&quot;) &quot;7
  echom len(&quot;foo&quot;) &quot;3

  字符串字符个数
  echom strchars(&quot;hello&quot;) &quot;5
  echom strchars(&quot;我的1&quot;) &quot;3

  字符串截取
  strcharpart({src}, {start} [, {len}])
  echo strcharpart(&quot;我的123&quot;,0,2) &quot;我的
  echo strcharpart(&quot;我的123&quot;,-1,2) &quot;我,start为负，就是从0开始，截取start+len个字符
  echo strcharpart(&quot;我的123&quot;,-1,3) &quot;我的
  echo strcharpart(&quot;我的123&quot;,-1,4) &quot;我的1

  echo &quot;abcdef&quot;[1:3] &quot; bcd
  echo &quot;abcdef&quot;[1:1] &quot; b
  echo &quot;abcdef&quot;[1:] &quot; bcdef
  echo &quot;我的123&quot;[3,6] &quot;的1

	
  分割,默认通过空格分割
  split({expr} [, {pattern} [, {keepempty}]])			*split()*

  echo split(&quot;one two three&quot;) &quot; [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;] 不能用echom输出一个list
  echo split(&quot;one,two,three,&quot;,&quot;) &quot; [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;] 不能用echom输出一个list,最后一个,不会有用

  连接,默认通过空格连接
  echo join([&quot;hello&quot;,&quot;world&quot;]) &quot;  hello world
  echo join([&quot;hello&quot;,&quot;world&quot;],&quot;,&quot;) &quot; hello,world
  echo join([&quot;hello&quot;,&quot;world&quot;],&quot;&quot;) &quot; helloworld

  大小写转换
  echom tolower(&quot;FOo&quot;)
  echom toupper(&quot;hello&quot;)
	
  字符串查找
  stridx({haystack}, {needle} [, {start}])
  :echo stridx(&quot;An Example&quot;, &quot;Example&quot;)	     3
  :echo stridx(&quot;Starting point&quot;, &quot;Start&quot;)    0
  :echo stridx(&quot;Starting point&quot;, &quot;start&quot;)   -1

  string()强制转化为字符串
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;列表&quot;&gt;列表&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;help List		
列表是有序的，元素的集合, 每一个item可以是任何type	
echo ['foo',34,12.2]	
echo ['foo',[3,'bar']]

索引,从0开始
echo [1,23,[1,34]][0] &quot; 1
echo [1,23,[1,34]][2][1] &quot; 34
echo [1,23,[1,34]][-1] &quot;[1,34]

切割,和python相似，但不同
echo [1,3,4,5][0:2] &quot;[1,3,4]
echo [1,3,4,5][0:20000] &quot;[1,3,4,5] 超过列表索引也是安全的。
echo [1,3,5,6][-2:-1] &quot; [5,6]
echo [1,2,3,5][:1] &quot;[1,2]
echo [1,2,3,5][2:] &quot;[3,5]
字符串也可以切割

连接+
echo ['a','b'] + ['c']  &quot; ['a','b','c']

函数列表
1.add
let foo = ['a']
call add(foo,'b') &quot; 往foo后面加上'b'
echo foo &quot; ['a','b']

2.len
echo len(foo) &quot; 2

3.get,返回指定索引的值
echo get(foo,0,'default') &quot; a
echo get(foo,10,'default') &quot; default

4.index
echo index(foo,'b') &quot;1
echo index(foo,'cet') &quot; -1  不存在返回-1

5.join

6.reverse ,转置
echo reverse(['a','b']) &quot;['b','a']

7.List unpack
let [var1, var2; rest] = mylist &quot;等同于下面三个表达式
let var1 = mylist[0]
let var2 = mylist[1]
let rest = mylist[2:]

8.复制和深度复制
let aa = [1,2,4]
let bb = aa &quot;aa 和bb 指向同一个列表，改变其中一个，也对相应改变另一个

let aa = [[1,'a'],3,4]
let bb = copy(aa) &quot; 浅复制，改变已经有的元素(该元素也是一个列表），aa和bb都会变化，但是，往aa中追加元素，不会影响
let aa[0][1] = 'aaa' &quot; 浅复制，所以 bb[0][1] == 'aaa'

如果要做到完全独立，就用deepcopy()
let cc = deepcopy(aa) &quot; 这样，cc和aa就是完全独立的变量,不会相会影响了。

9.列表相等
echo [1,3] == [1,3] &quot; 1 ,true 
echo [3,1] == [1,3] &quot; 0 ,false
echo 2 == &quot;2&quot; &quot; 1,true 
echo [2] == [&quot;2&quot;] &quot; 0, false

let a = [1,3]
let b = [1,3]
echo a is b &quot; 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;字典&quot;&gt;字典&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;类似python中的dict，ruby中的hash, javascript中的object
字典用花括号创建,索引是字符串（即便定义的时候是数字，也会被转化为字符串)

:echo {'a':1,'100':'foo',} &quot; 字典最后可以留下一个逗号,js的愚蠢之处，在这里被修复了

let dic = {'a':1,'100':'foo',}
echo dic['a'] &quot; 1

当键是字母数字下划线组成时，字典也支持&quot;点&quot;查找
echo dic.a
echo dic.100

赋值和添加，移除项
let dic.a = 222
let dic.c = 'new val'

let a = remove(dic,'a') &quot; 此方法移除a后，会返回a对应的值
unlet dic.a &quot;直接移除a，不会返回

字典函数
echo get(dic,'a','default') &quot; 1 和list一样
echo get(dic,'dd','not') &quot; not

echo has_key(dic, &quot;a&quot;) &quot; 1

echo items(dic) &quot; [['a',1],['100','foo']]
echo  keys(dic) &quot;['a','100']
echo values(dic) &quot;[1,'foo']

遍历Dictionary
for key in keys(dic)
	echo key.&quot;:'.dic[key]
endfor

for v in values(dic)
	echo &quot;value:&quot;.v
endfor

for [k,v] in items(dic)
	echo k.':'.v
endfor

合并数组
call extend(adic, bdic) &quot;把bdic的值，加到a中，如果有重复的key，a的会被b覆盖(默认)

过滤元素
call filter(dict, 'v:val =~ &quot;x&quot;') &quot; 把value匹配&quot;x&quot;的元素都剔除掉。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;函数funcref&quot;&gt;函数(Funcref)&lt;/h4&gt;

&lt;h4 id=&quot;特殊special&quot;&gt;特殊(Special)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;v:false
v:true
v:none
v:null
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;任务job&quot;&gt;任务(Job)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;job_start()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;通道channel&quot;&gt;通道(channel)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ch_open()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对大部分命令和选项，vim支持他们的缩写。但是建议在vimrc或者自己编写的插件中使用全称，这样才会有更好的可读性。&lt;/p&gt;</content><author><name></name></author><category term="vimscript" /><summary type="html">既然把vimscript是一个脚本语言，那就会有脚本语言的一些共性，比如变量的定义,变量的类型，变量的作用域，分支循环结构,函数等等。</summary></entry><entry><title type="html">A devops flow</title><link href="http://localhost:4000/devops-flow/" rel="alternate" type="text/html" title="A devops flow" /><published>2019-01-23T00:00:00+08:00</published><updated>2019-01-23T00:00:00+08:00</updated><id>http://localhost:4000/devops-flow</id><content type="html" xml:base="http://localhost:4000/devops-flow/">&lt;div class=&quot;mermaid&quot;&gt;
graph TB
	
	subgraph devops
		test((&quot;fa:fa-users Test&quot;))
		dev((&quot;fa:fa-user Dev&quot;))
		ops((&quot;Ops&quot;))
		branch(&quot;branch&quot;)

		dev --&amp;gt;|创建分支| branch
		branch --&amp;gt;|jenkins| jenkins[&quot;jenkins&quot;]
	end
	
	tes1t[&quot;fa:fa-camera-retro:5x Camera&quot;]

	jenkins[&quot;fa:fa-futbol:fa-5x Iggool&quot;]

     classDef green fill:#9f6,stroke:#333,stroke-width:2px;
     classDef orange fill:#f96,stroke:#333,stroke-width:4px;
     class sq,e green
     class di orange

&lt;/div&gt;</content><author><name></name></author><summary type="html">graph TB subgraph devops test((&quot;fa:fa-users Test&quot;)) dev((&quot;fa:fa-user Dev&quot;)) ops((&quot;Ops&quot;)) branch(&quot;branch&quot;)</summary></entry><entry><title type="html">Some note about vimrc</title><link href="http://localhost:4000/vimscript-note-1/" rel="alternate" type="text/html" title="Some note about vimrc" /><published>2019-01-23T00:00:00+08:00</published><updated>2019-01-23T00:00:00+08:00</updated><id>http://localhost:4000/vimscript-note-1</id><content type="html" xml:base="http://localhost:4000/vimscript-note-1/">&lt;h3 id=&quot;启动vim不加载vimrc&quot;&gt;启动vim不加载.vimrc&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim -u NONE -N    -N 就是和vi不兼容
-u &amp;lt;vimrc&amp;gt;		Use &amp;lt;vimrc&amp;gt; instead of any .vimrc
-N			Not fully Vi compatible: 'nocompatible' ### 注释 

&quot;  这就是注释,双引号之后的就是注释内容
但是下面的注释会失效。。
:map &amp;lt;space&amp;gt; viw &quot; 按下空格键高亮选中一个单词	

所以vim的注释，最好不要行末添加
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;切换布尔选项&quot;&gt;!切换布尔选项&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:set number!   或:set nu!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;查看配置的值&quot;&gt;?查看配置的值&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:set fileencoding? 返回fileencoding=utf-8
:set number? 返回 number 或 nonumber
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;键盘映射&quot;&gt;键盘映射&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;normal模式下的简单映射&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  :map - dd   按下 - 就相当于dd，会删除一行
  也可以用&amp;lt;keyname&amp;gt;来告诉vim一个特殊的按键
  :map &amp;lt;space&amp;gt; viw  按下空格，vim将高亮选中一个单词
	
  :unmap - 取消-的映射
  :unmap &amp;lt;space&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nmap 在normal模式下的映射&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  :nmap - ddp
  取消映射
  :nunmap -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;vmap 在visual模式下的映射&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  visual模式下，按下\,会把小写字母变大写
  :vmap \ U 
  取消映射
  :vunmap \
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;imap 在insert模式下的映射&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  在insert模式下，ctrl+d 会删除一行
  :imap &amp;lt;c-d&amp;gt; &amp;lt;esc&amp;gt;ddi   
  取消映射
  :iunmap &amp;lt;c-d&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;映射可能会出现递归调用&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  :nmap - dd
  :namp \ -
  在normal模式下，按下\,vim会解释为-,而 -会继续被解析为 dd，最后就是删除了一行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非递归映射*noremap&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  :nmap x dd
  :nnoremap \ x
  当按下\ 就是x，删除一个字符，vim不会把x再解析为dd

  ** 应该在所有的情况下使用 noremap **
  &quot; insert mode下jj --&amp;gt; &amp;lt;esc&amp;gt;
  inoremap jj &amp;lt;esc&amp;gt;
  noremap/nnoremap , vnoremap, inoremap
  取消非递归映射(和取消递归映射的方法一样)
  :unnmap  \

  :map x &amp;lt;nop&amp;gt; 就会让按键x失效

  :nnoremap &amp;lt;buffer&amp;gt; Q x 只在当前缓冲区生效
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;leaders导航键&quot;&gt;Leaders(导航键?)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim默认的leader是\

:let mapleader = &quot;-&quot;  把leader键设置为-
在配置文件的其他地方，就用&amp;lt;leader&amp;gt;,而不是&quot;-&quot;

local leader 这个leader只用于那些对某类文件(python,html)而设置的映射

:let maplocalleader = &quot;\\&quot;  把loacalleader设置为\,以为\\会转意为\
如果要设定一个只会用户特定缓冲区的映射，一般会使用 &amp;lt;localleader&amp;gt;,而不是&amp;lt;leader&amp;gt;
使用&amp;lt;leader&amp;gt;和&amp;lt;localleader&amp;gt;按键就像设置了一种命名空间,
用&amp;lt;localleader&amp;gt;来设置本地映射，会防止你的插件覆盖别人的全局映射

打开vimrc文件
nnoremap &amp;lt;leader&amp;gt;ev :vsplit $MYVIMRC&amp;lt;cr&amp;gt;
重新加载vimrc文件
nnoremap &amp;lt;leader&amp;gt;sv :source $MYVIMRC&amp;lt;cr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;abbreviations&quot;&gt;Abbreviations&lt;/h3&gt;

&lt;p&gt;在一个abbrevivation后输入一个 non-keyword character后，vim会替换那个abbrevivation
not-keyword character指的是那些不在iskeyword选项中的字符(iskeyword=@,48-57,_,192-255)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;insert模式下的abbrevivations&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  :iabbrev adn and
  :iabbrev ture true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;replace模式下的abbrevivations&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;command模式下的abbrevivations&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;自动命令&quot;&gt;自动命令&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:autocmd BufNewFile * :write  &quot;该命令会在打开一个文件后，自动自动保存
         ^          ^ ^
         |          | |
         |          | 要执行的命令
         |          | 
         |          用于事件过滤的&quot;模式pattern&quot; 
         |           
         要监听的事件          

:autocmd BufNewFile *.php :write  只会保存php文件
:autocmd BufWritePre *.html :normal gg=G  在保存html文档之前，先格式化
多个事件用逗号分隔
:autocmd BufNewFile,BufRead *.html setlocal nowarp
vim脚本编程中，一般会同时使用BufRead和BufNewFile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;FileType 事件&lt;/p&gt;

    &lt;p&gt;针对不同的文件，设置一些有用的映射,比如注释
  可以设置localleader为,,
  :let maplocalleader=”,,”
  :autocmd FileType erlang nnoremap &lt;buffer&gt; &lt;localleader&gt;c I%%&lt;esc&gt;
  然后打开一个erlang文件，normal模式下，按下,,c 就可以注释一行&lt;/esc&gt;&lt;/localleader&gt;&lt;/buffer&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;本地缓冲区缩写&lt;/p&gt;

    &lt;p&gt;:iabbrev &lt;buffer&gt; --- test  对当前缓冲区生效，会覆盖如下的全局设置
  :iabbrev  --- tes2   会话的所有缓冲区都生效，但是优先级没有&lt;buffer&gt;定义的缩写高&lt;/buffer&gt;&lt;/buffer&gt;&lt;/p&gt;

    &lt;p&gt;:autocmd FileType php :iabbrev &lt;buffer&gt; iff if () {&lt;cr&gt;}&lt;cr&gt;&lt;esc&gt;kkA&lt;left&gt;&lt;left&gt;&lt;left&gt;
  :sleep 10m 睡眠10ms&lt;/left&gt;&lt;/left&gt;&lt;/left&gt;&lt;/esc&gt;&lt;/cr&gt;&lt;/cr&gt;&lt;/buffer&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;自动命令组grouping-autocommands&quot;&gt;自动命令组Grouping Autocommands&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:aug[roup] {name}  group name 大小写敏感
	...
:augroup end/END

:augroup testgroup
:autocmd BufWrite * : echom &quot;foo&quot;
:autocmd BufWrite * : echom &quot;bar&quot;
:augroup END

定义两个名称相同的命令组，一般情况下，后面定义的不会覆盖前面的,除非把autocmd!放在组里
:augroup testgroup
:autocmd!
:autocmd BufWrite * : echom &quot;test&quot;
:augroup END

更多详情： :help autocmd-groups
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;operator-pending映射&quot;&gt;Operator-Pending映射&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:help omap-info 	

Operator-pending mappings can be used to define a movement command that can be
used with any operator.  Simple example: &quot;:omap { w&quot; makes &quot;y{&quot; work like &quot;yw&quot;
and &quot;d{&quot; like &quot;dw&quot;.

:onoremap { :&amp;lt;c-u&amp;gt;normal! 0f{vi{&amp;lt;cr&amp;gt;   &quot;在包含{}的一行，执行d{、c{、y{  就可以删除/改变/复制{}之间的内容
:onoremap ( :&amp;lt;c-u&amp;gt;normal! 0f(vi(&amp;lt;cr&amp;gt;  &quot;在包含()的一行，执行d(、c(、y(  就可以删除/改变/复制()之间的内容 

The CTRL-U (&amp;lt;C-U&amp;gt;) is used to remove the range that Vim may insert. 


:onoremap ih :&amp;lt;c-u&amp;gt;execute &quot;normal! ?^==\\+$\r:nohlsearch\rkvg_&quot;&amp;lt;cr&amp;gt;

normal! 可以执行一些命令，但是遇到特殊字符就不行了，比如&amp;lt;cr&amp;gt;
execute 把后面的字符串当作命令来执行。特殊字符需要转义,如\r代表回车 \\代表\

g_: 移动到当前行的最后一个非空字符。$会选中最后一个换行符
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;状态条statusline&quot;&gt;状态条statusline&lt;/h3&gt;

&lt;p&gt;statusline可以展示一些当前buffer内文件的信息，比如文件名称%f,完整路径%F, %m如果缓冲区内容修改表示为[+]
默认情况下，statusline是隐藏的。显示： &lt;code&gt;:set laststatus=2&lt;/code&gt;,隐藏 &lt;code&gt;:set laststatus=0&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;定制项目&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;参数意义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;%f&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;文件名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;%F&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;文件完整路径,我觉得这个完整路径有助于回答,我在哪里?&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;%m&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;如果缓冲区内容发生改变表示为[+],有助于你提醒自己，你在做什么？&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;%n&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;缓冲区号,&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;%y&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;文件类型，不过我觉得如果输出了文件名，这个有点多余&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;%v&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;虚列号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;%l&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;行号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;%L&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;总行数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;%=&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;之后的状态都是右对齐,在这个之前是左对齐&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;%{expr}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;表达式的结果，可以用这个定制很多特性的状态&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我的statusline设置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set statusline=buf%n\ %m
set statusline+=\ %l,%v/%L
set statusline+=\ %{&amp;amp;fileencoding?&amp;amp;fileencoding:&amp;amp;encoding} &quot;文件编码
set statusline+=\ [%{&amp;amp;fileformat}] &quot;文件类型
set statusline+=\ %{(exists(\&quot;bomb\&quot;)\ &amp;amp;&amp;amp;\ &amp;amp;bomb)?\&quot;Bom\&quot;:\&quot;\&quot;} &quot;如果有bomb头，就会显示Bom
set statusline+=%{StatuslineGit()} &quot;显示git分支名称,需要定义如下两个函数
set statusline+=\ %F

function! GitBranch()
  return system(&quot;git rev-parse --abbrev-ref HEAD 2&amp;gt;/dev/null | tr -d '\n'&quot;)
endfunction

function! StatuslineGit()
  let l:branchname = GitBranch()
  return strlen(l:branchname) &amp;gt; 0?'  '.l:branchname.' ':''
endfunction


\&amp;lt;space&amp;gt; 是空格
最后的效果如下：
buf1  223,5/365 utf-8 [unix]   master  ~/Documents/github.io/_posts/2019-01-23-vimscript-note-1.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;autocmd-所有的事件&quot;&gt;autocmd 所有的事件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;:help autocmd-events&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Name			triggered by ~

	Reading
|BufNewFile|		starting to edit a file that doesn't exist
|BufReadPre|		starting to edit a new buffer, before reading the file
|BufRead|		starting to edit a new buffer, after reading the file
|BufReadPost|		starting to edit a new buffer, after reading the file
|BufReadCmd|		before starting to edit a new buffer |Cmd-event|

|FileReadPre|		before reading a file with a &quot;:read&quot; command
|FileReadPost|		after reading a file with a &quot;:read&quot; command
|FileReadCmd|		before reading a file with a &quot;:read&quot; command |Cmd-event|

|FilterReadPre|		before reading a file from a filter command
|FilterReadPost|	after reading a file from a filter command

|StdinReadPre|		before reading from stdin into the buffer
|StdinReadPost|		After reading from the stdin into the buffer

	Writing
|BufWrite|		starting to write the whole buffer to a file
|BufWritePre|		starting to write the whole buffer to a file
|BufWritePost|		after writing the whole buffer to a file
|BufWriteCmd|		before writing the whole buffer to a file |Cmd-event|

|FileWritePre|		starting to write part of a buffer to a file
|FileWritePost|		after writing part of a buffer to a file
|FileWriteCmd|		before writing part of a buffer to a file |Cmd-event|

|FileAppendPre|		starting to append to a file
|FileAppendPost|	after appending to a file
|FileAppendCmd|		before appending to a file |Cmd-event|

|FilterWritePre|	starting to write a file for a filter command or diff
|FilterWritePost|	after writing a file for a filter command or diff

	Buffers
|BufAdd|		just after adding a buffer to the buffer list
|BufCreate|		just after adding a buffer to the buffer list
|BufDelete|		before deleting a buffer from the buffer list
|BufWipeout|		before completely deleting a buffer

|BufFilePre|		before changing the name of the current buffer
|BufFilePost|		after changing the name of the current buffer

|BufEnter|		after entering a buffer
|BufLeave|		before leaving to another buffer
|BufWinEnter|		after a buffer is displayed in a window
|BufWinLeave|		before a buffer is removed from a window

|BufUnload|		before unloading a buffer
|BufHidden|		just after a buffer has become hidden
|BufNew|		just after creating a new buffer

|SwapExists|		detected an existing swap file

	Options
|FileType|		when the 'filetype' option has been set
|Syntax|		when the 'syntax' option has been set
|EncodingChanged|	after the 'encoding' option has been changed
|TermChanged|		after the value of 'term' has changed
|OptionSet|		after setting any option

	Startup and exit
|VimEnter|		after doing all the startup stuff
|GUIEnter|		after starting the GUI successfully
|GUIFailed|		after starting the GUI failed
|TermResponse|		after the terminal response to |t_RV| is received

|QuitPre|		when using `:quit`, before deciding whether to quit
|VimLeavePre|		before exiting Vim, before writing the viminfo file
|VimLeave|		before exiting Vim, after writing the viminfo file

	Various
|FileChangedShell|	Vim notices that a file changed since editing started
|FileChangedShellPost|	After handling a file changed since editing started
|FileChangedRO|		before making the first change to a read-only file

|ShellCmdPost|		after executing a shell command
|ShellFilterPost|	after filtering with a shell command

|CmdUndefined|		a user command is used but it isn't defined
|FuncUndefined|		a user function is used but it isn't defined
|SpellFileMissing|	a spell file is used but it can't be found
|SourcePre|		before sourcing a Vim script
|SourceCmd|		before sourcing a Vim script |Cmd-event|

|VimResized|		after the Vim window size changed
|FocusGained|		Vim got input focus
|FocusLost|		Vim lost input focus
|CursorHold|		the user doesn't press a key for a while
|CursorHoldI|		the user doesn't press a key for a while in Insert mode
|CursorMoved|		the cursor was moved in Normal mode
|CursorMovedI|		the cursor was moved in Insert mode

|WinNew|		after creating a new window
|TabNew|		after creating a new tab page
|TabClosed|		after closing a tab page
|WinEnter|		after entering another window
|WinLeave|		before leaving a window
|TabEnter|		after entering another tab page
|TabLeave|		before leaving a tab page
|CmdwinEnter|		after entering the command-line window
|CmdwinLeave|		before leaving the command-line window

|InsertEnter|		starting Insert mode
|InsertChange|		when typing &amp;lt;Insert&amp;gt; while in Insert or Replace mode
|InsertLeave|		when leaving Insert mode
|InsertCharPre|		when a character was typed in Insert mode, before
			inserting it

|TextChanged|		after a change was made to the text in Normal mode
|TextChangedI|		after a change was made to the text in Insert mode
|TextYankPost|		after text is yanked or deleted

|ColorScheme|		after loading a color scheme

|RemoteReply|		a reply from a server Vim was received

|QuickFixCmdPre|	before a quickfix command is run
|QuickFixCmdPost|	after a quickfix command is run

|SessionLoadPost|	after loading a session file

|MenuPopup|		just before showing the popup menu
|CompleteDone|		after Insert mode completion is done

|User|			to be used in combination with &quot;:doautocmd&quot;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="vim" /><category term="vimscript" /><category term="statusline" /><summary type="html">启动vim不加载.vimrc</summary></entry><entry><title type="html">The new git branch model(add G1)</title><link href="http://localhost:4000/new-git-branch/" rel="alternate" type="text/html" title="The new  git branch model(add G1)" /><published>2019-01-22T00:00:00+08:00</published><updated>2019-01-22T00:00:00+08:00</updated><id>http://localhost:4000/new-git-branch</id><content type="html" xml:base="http://localhost:4000/new-git-branch/">&lt;div class=&quot;mermaid&quot;&gt;
	sequenceDiagram
		participant MasterG2
		participant Master
		participant Dev as F分支
		participant Bg0
		participant Bg2 as Bg2/F2
		participant Test
		participant Release
		participant ReleaseG2

		Note over Master,Release:特性分支(f分支)开发流程 
		Master -&amp;gt;&amp;gt;+ Dev:开发拉f分支
		Dev --&amp;gt;&amp;gt; Dev: 开发自测
		loop 提测
			Dev -&amp;gt;&amp;gt; Test:F分支合并到Test分支
			Note over Test:是否有冲突
			alt 没有有冲突
				Note over Test :jenkins构建test环境
				Note over Test:验证测试环境
				alt 测试环境验证通过
					Note over Dev :F分支能否合并到Release分支
					alt 能合并
						Dev -&amp;gt;&amp;gt; Release:F分支合并到Release
						Note over Release :是否有冲突
						alt 没有冲突
							Note over Release :jenkins构建beta g0
							Note over Release:验证beta g0环境
							alt beta g0环境验证通过
								Note over Release: 积累一天
								Note over Release : jenkins构建prod g0
								Note over Release : 验证prod g0
								alt prod g0验证通过
									Release -&amp;gt;&amp;gt;- Dev : 删除所有的合并到Relase的F分支
									Release -&amp;gt;&amp;gt; Master : Release分支合并到Master
								else prod g0没有验证通过
									Release --&amp;gt;&amp;gt; Dev: prod g0验证没有通过，排查原因
								end
							else
								Release --&amp;gt;&amp;gt; Dev: beta g0测试不通过, 排查问题
							end
						else  有冲突
							Release --&amp;gt;&amp;gt; Dev : 开发同学先解决冲突,再次提测
						end
					else F分支不能合并到Release,原因：
						Note over Dev: 过了14:00
						Note over Dev: 距离灰度发布不足两天
						Note over Dev: 灰度发布期间
					end
				else 测试环境验证不通过
					Test --&amp;gt;&amp;gt; Dev:测试环境不通过,排查问题
				end
			else 有冲突
				Test --&amp;gt;&amp;gt; Dev :先解决冲突，再提测
			end
		end

		Note over Master,Release:Bg0分支开发流程(解决线上g0环境的bug)
		Note over Release: 灰度前后验证prod G0环境
		alt prod g0环境验证通过
		else prod g0验证不通过
			Master -&amp;gt;&amp;gt;+ Bg0 : 从Master拉取一个Bg0分支
			Bg0 --&amp;gt;&amp;gt; Bg0 : 开发自测
			Bg0 -&amp;gt;&amp;gt; Test : 合并到Test分支
			alt Bg0合并到Test没有冲突
				Note over Test:	jenkins 构建测试环境，并验证
				alt 测试环境验证通过
					Bg0 -&amp;gt;&amp;gt; Release: Bg0合并到Release分支 
					alt 合并没有冲突
						Note over Release :jenkins构建beta g0环境，并验证
						alt beta g0验证通过
							Note over Release:构建 prod g0,并验证
							alt prod g0通过
								Release -&amp;gt;&amp;gt; Master: 合并到Master分支,删除Bg0分支
								deactivate Bg0
							else  失败
								Release --&amp;gt;&amp;gt; Bg0 : prod g0未通过，排查原因，再提测
							end
						else 失败
							Release --&amp;gt;&amp;gt; Bg0: beta g0未通过，排查原因，再提测	
						end
					else Bg0合并Release发生冲突
						Release --&amp;gt;&amp;gt; Bg0: 解决冲突，重新提测
					end
				else 测试环境验证不通过
					Test --&amp;gt;&amp;gt; Bg0: 查找原因，重新提测
				end
			else Bg0合并到Test有冲突 
				Test --&amp;gt;&amp;gt; Bg0:解决冲突，重新提测	
			end
		end

		Note over MasterG2, ReleaseG2 : 全量发布
		Note right of ReleaseG2:prod环境全量发布
		Note over Release,ReleaseG2 :把prod g2的租户漂移到prod g0环境
		Release -&amp;gt;&amp;gt; ReleaseG2: Release分支合并到RelaseG2
		Note over ReleaseG2:jenkins构建prod g2环境
		Note over Release,ReleaseG2 :把大部分prod g0租户漂移回prod g2环境

		Note right of ReleaseG2:beta环境全量发布
		Note over Release,ReleaseG2 :把beta g2的租户漂移到beta g0环境
		Note over ReleaseG2:jenkins构建beta g2环境
		Note over Release,ReleaseG2 :把大部分beta g0租户漂移回beta g2环境

		ReleaseG2 -&amp;gt;&amp;gt; MasterG2 : 全量发布完成，ReleaseG2合并到MasterG2



		Note over MasterG2,ReleaseG2:Bg2/F2分支开发流程(解决线上g2环境的bug(Bg2分支),或G2环境的需求(F2分支))
		MasterG2 -&amp;gt;&amp;gt;+ Bg2: 拉取Bg2/F2分支	
		Bg2 --&amp;gt;&amp;gt; Bg2: 开发自测
		Bg2 -&amp;gt;&amp;gt; Test: 合并到test分支
		Note over Test:jenkins构建测试环境，并验证
		alt 测试环境验证通过
			Bg2 -&amp;gt;&amp;gt; ReleaseG2 : 合并到ReleaseG2分支
			alt 合并成功，没有冲突
				Note over ReleaseG2:jenkins构建beta g2环境
				Note over ReleaseG2:在beta g2环境验证
				alt beta g2环境验证通过
					Note over ReleaseG2: jenkins构建prod g1环境
					Note right of  ReleaseG2: 从G2选取部分租户&lt;br /&gt;漂移到prod g1
					alt prod g1的租户验证通过
						Note over ReleaseG2: 在prod g1等待	
					else prod g1租户验证不通过
						ReleaseG2 --&amp;gt;&amp;gt; Bg2:验证不通过，查原因，重新提测
					end
					Note right of  ReleaseG2: 租户在prod g1上&lt;br /&gt;过了观察期(如1天)
					Note right of  ReleaseG2: 把租户全部漂移&lt;br /&gt;到prod g1
					Note over ReleaseG2: jenkins构建prod g2环境
					Note right of  ReleaseG2: 把prod g1租户&lt;br /&gt;全部漂移到prod g2
					ReleaseG2 -&amp;gt;&amp;gt; Release : 合并到Release
					ReleaseG2 -&amp;gt;&amp;gt; MasterG2: 合并到MasterG2&lt;br /&gt;并删除Bg2分支
					deactivate Bg2
				else beta g2环境验证不通过
					ReleaseG2 --&amp;gt;&amp;gt; Bg2: beta g2验证不通过，查原因，重新提测
				end
			else Bg2/F2合并ReleaseG2,发生冲突 
				ReleaseG2 --&amp;gt;&amp;gt; Bg2:解决冲突，重新接测	
			end
		else
			Test --&amp;gt;&amp;gt; Bg2:测试环境不通过，查原因，重新提测
		end
&lt;/div&gt;</content><author><name></name></author><summary type="html">sequenceDiagram participant MasterG2 participant Master participant Dev as F分支 participant Bg0 participant Bg2 as Bg2/F2 participant Test participant Release participant ReleaseG2</summary></entry><entry><title type="html">Dependence and Data Provider in PHPUnit</title><link href="http://localhost:4000/php-unit-test-note2/" rel="alternate" type="text/html" title="Dependence and Data Provider in PHPUnit" /><published>2019-01-22T00:00:00+08:00</published><updated>2019-01-22T00:00:00+08:00</updated><id>http://localhost:4000/php-unit-test-note2</id><content type="html" xml:base="http://localhost:4000/php-unit-test-note2/">&lt;h3 id=&quot;牛人的话翻译后&quot;&gt;牛人的话(翻译后)&lt;/h3&gt;

&lt;p&gt;Adrian Kuhn et.al:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;写单元测试是一个非常好的做法，帮助开发定位和修复bug，重构代码并作为测试软件的一个单元的文档。
为了能达到这个效果，单元测试要考虑到程序中所有路径。一个方法或函数通常只覆盖一个特殊的路径。
然而，一个测试方法并不是一个封闭的，独立的实体。通常在测试方法之间的隐式依赖，就藏在某个测试场景的实现中。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;test-dependencies&quot;&gt;Test Dependencies&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;producer: 返回值给其他方法使用的方法&lt;/li&gt;
  &lt;li&gt;consumer: 依靠别的方法和它们的返回值的方法&lt;/li&gt;
  &lt;li&gt;一个方法，可以兼顾这个两个角色&lt;/li&gt;
  &lt;li&gt;consumer方法需要在方法注释中标注@depends testFunc&lt;/li&gt;
  &lt;li&gt;一个consumer方法可以一个或多个@depends,当有多个@depends时，@depends的声明顺序就是consumer参数顺序
    &lt;ul&gt;
      &lt;li&gt;参数的传递，默认是引用传参&lt;/li&gt;
      &lt;li&gt;@depends clone 就是深复制，传值传参&lt;/li&gt;
      &lt;li&gt;@depends shallowClone 浅复制&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;consumer方法有多个@depends时，要确保这些producer方法要写在consumer的前面，不然就会出现skip&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;PHPUnit\Framework\TestCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MultipleDependenciesTest&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TestCase&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testProducerFirst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nv&quot;&gt;$this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assertTrue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'first'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testProducerSecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nv&quot;&gt;$this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assertTrue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'second'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;sd&quot;&gt;/**
	 * @depends testProducerFirst
	 * @depends testProducerSecond
	 */&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testConsumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nv&quot;&gt;$this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assertSame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'first'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;nv&quot;&gt;$this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assertSame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'second'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;data-providers&quot;&gt;Data Providers&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;某个方法的注释中用 &lt;code&gt;@dataProvider &lt;/code&gt;这个特殊注释 标识了某个方法，则这个方法就是data provider
    &lt;ul&gt;
      &lt;li&gt;如&lt;code&gt;@dataProvider testFunc&lt;/code&gt; testFunc就是data provider&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;data provider返回值必须要是n维数组(n&amp;gt;=2),或可以迭代的对象(Iterator),并且这个对象每一次迭代都要返回一个数组&lt;/li&gt;
  &lt;li&gt;测试方法的参数可以由一个或多个data provider 提供&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当测试方法同时有@dataProvider和@depends时，@dataProvider的参数要先于@depends&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;demo&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;PHPUnit\Framework\TestCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DependencyAndDataProviderComboTest&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TestCase&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;provider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'provider1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'provider2'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]];&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testProducerFirst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nv&quot;&gt;$this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assertTrue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'first'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testProducerSecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nv&quot;&gt;$this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assertTrue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'second'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;sd&quot;&gt;/**
	 * @depends testProducerFirst
	 * @depends testProducerSecond
	 * @dataProvider provider
	 */&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testConsumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nv&quot;&gt;$this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assertSame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'provider1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'first'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'second'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
			&lt;span class=&quot;nb&quot;&gt;func_get_args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
			&lt;span class=&quot;sd&quot;&gt;/**
			func_get_args()依次是
			['provider1', 'first', 'second'],
			['provider2', 'first', 'second']
			因为 provider迭代了两次，第一次返回['provider1'], 字符串'provider1'就传递给了testConsumer，作为第一个参数，
			**/&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">牛人的话(翻译后)</summary></entry></feed>