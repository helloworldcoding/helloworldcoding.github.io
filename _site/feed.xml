<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-03-07T09:19:33+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hello world, Let’s Coding!</title><subtitle>Keeping looking,don't settle.</subtitle><entry><title type="html">My tmux config</title><link href="http://localhost:4000/tmux-note/" rel="alternate" type="text/html" title="My tmux config" /><published>2019-03-08T00:00:00+08:00</published><updated>2019-03-08T00:00:00+08:00</updated><id>http://localhost:4000/tmux-note</id><content type="html" xml:base="http://localhost:4000/tmux-note/">&lt;h4 id=&quot;窗口window和分区span快速切换&quot;&gt;窗口(window)和分区span快速切换&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bind-key num
在配置文件中加入`bind-key C-w last-window`就可以通过bind-key Ctrl+w来切换上次和当前的window了

`bind-key C-a last-span`，就可以通过bind-key Ctrl+a来切换上次和和当前的span
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="tmux" /><summary type="html">窗口(window)和分区span快速切换</summary></entry><entry><title type="html">My tour of golang</title><link href="http://localhost:4000/golang-basic/" rel="alternate" type="text/html" title="My tour of golang" /><published>2019-03-07T00:00:00+08:00</published><updated>2019-03-07T00:00:00+08:00</updated><id>http://localhost:4000/golang-basic</id><content type="html" xml:base="http://localhost:4000/golang-basic/">&lt;h4 id=&quot;basic-types&quot;&gt;Basic types&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;bool   默认值false&lt;/li&gt;
  &lt;li&gt;string 默认值””&lt;/li&gt;
  &lt;li&gt;int  int8 int16 int32 int64 默认值0&lt;/li&gt;
  &lt;li&gt;uint uint8 uint16 uint32 uint64 uintptr&lt;/li&gt;
  &lt;li&gt;byte // int8的别名&lt;/li&gt;
  &lt;li&gt;rune // int32的别名,代表unicode值&lt;/li&gt;
  &lt;li&gt;float32 float64 默认值0&lt;/li&gt;
  &lt;li&gt;complex64 complex128&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;类型转换&quot;&gt;类型转换&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;T(v) 显示类型转换，如int(12.4),string(11244)
    &lt;ul&gt;
      &lt;li&gt;不过整型转为string是按照ascii码或unicode码转为对应的字符，所以有可能得到乱码&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;原类型\转化后&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;bool&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;int&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;float&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;string&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;complex&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;bool&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;int&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;float&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;string&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;complex&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;variables-with-initializers变量和初始化&quot;&gt;Variables with initializers(变量和初始化)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 再函数内部以下三种写法都一样
var i,j int = 1, 3  // 全局可以用
var i, j = 1,3     // 全局可以用
i,j := 1,3 // 只能在函数体内部使用
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="golang" /><summary type="html">Basic types</summary></entry><entry><title type="html">dbext an awesome database client</title><link href="http://localhost:4000/dbext-vim-db-explorer/" rel="alternate" type="text/html" title="dbext an awesome database client" /><published>2019-02-19T00:00:00+08:00</published><updated>2019-02-19T00:00:00+08:00</updated><id>http://localhost:4000/dbext-vim-db-explorer</id><content type="html" xml:base="http://localhost:4000/dbext-vim-db-explorer/">&lt;h1 id=&quot;可能是最适合开发的数据库客户端&quot;&gt;可能是最适合开发的数据库客户端&lt;/h1&gt;

&lt;h4 id=&quot;支持的数据库类型&quot;&gt;支持的数据库类型:&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SAP Sybase SQL Anywhere (SA/ASA)
SAP Sybase IQ
SAP Sybase Adaptive Server Enterprise (ASE)
SAP HANA
SAP Sybase UltraLite (UL)
Oracle
Oracle RDB
SQL Server
MySQL
PostgreSQL
DB2
Firebird
Ingres
Interbase
SQLite
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;本文以MySQL为例，介绍一下该插件的功能。&lt;/p&gt;

&lt;h3 id=&quot;安装配置&quot;&gt;安装&amp;amp;配置&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Lets test the connection, run the following command (Note the capital S): &amp;gt;
`:Select * from customer`
Select, Update, Insert, Delete, Call, Drop, Alter, Create
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;功能介绍&quot;&gt;功能介绍&lt;/h3&gt;

&lt;h4 id=&quot;connect&quot;&gt;connect&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;使用快捷键 ：`&amp;lt;leader&amp;gt;sbp` leader键默认是`\`,  sbp(sql buffer prompt)
使用ex命令：`:DBPromptForBufferParameters`
然后选择要连接的数据库类型
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;execute&quot;&gt;execute&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;把光标置于sql语句中的任意位置（sql语句是一行）
`&amp;lt;leader&amp;gt;sel`  sql execute line

执行多行sql
`&amp;lt;leader&amp;gt;se`  sql execute 
`:DBExecSQLUnderCursor`

执行选中的sql
`:DBExecVisualSQL`
&amp;lt;leader&amp;gt;se  和多行执行一样

从表中查选,光标在表名称的单词上
`&amp;lt;leader&amp;gt;st`  sql table
`:DBSelectFromTable`
执行的sql是：select * from table_name

带条件的查询
`&amp;lt;leader&amp;gt;stw`
`:DBSelectFromTableWithWhere`
会提示你输入where条件， 比如 id &amp;gt; 1 and name like &quot;zhangsan&quot;
执行的sql：select * from table_name where id &amp;gt; 1 and name like &quot;zhangsan&quot;

等待输入表名查询
`&amp;lt;leader&amp;gt;sta`
`:DBSelectFromTableAskName`
会提示你输入你要查询的表名

高亮选择表名查询
`&amp;lt;leader&amp;gt;st`
`:'&amp;lt;,'&amp;gt;DBSelectFromTable`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;describing-objects&quot;&gt;Describing objects&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;表结构
`:DBDescribeTable`
`\sdt` sql describe table

存储过程procedures
`:DBDescribeProcedure`
`\dp`  d (describe) p (procedure)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="vim" /><category term="database" /><category term="navicat" /><summary type="html">可能是最适合开发的数据库客户端</summary></entry><entry><title type="html">Vim delete swp&amp;amp;swo file</title><link href="http://localhost:4000/vimscript-delete-swp-swo-file/" rel="alternate" type="text/html" title="Vim delete swp&amp;swo file" /><published>2019-02-17T00:00:00+08:00</published><updated>2019-02-17T00:00:00+08:00</updated><id>http://localhost:4000/vimscript-delete-swp-swo-file</id><content type="html" xml:base="http://localhost:4000/vimscript-delete-swp-swo-file/">&lt;p&gt;写了一个小函数，来删除vim的swp和swo文件。&lt;/p&gt;

&lt;p&gt;在normal模式下，输入\ds就可以删除该文件对应的swp和swo文件。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot; 删除当前文件对应的swp和swo文件
function! DeleteSpaw()
	let l:fname = fnameescape(expand('%:t'))
	let l:swp = '.'.l:fname.'.swp'
	let l:swo = '.'.l:fname.'.swo'
	if CheckFile(l:swp)
		echom DeleteFile(l:swp) == 1 ? l:swp.' delete successfully' : l:swp.' delete faild '
	endif
	if CheckFile(l:swo)
		echom DeleteFile(l:swo) == 1 ? l:swo.' delete successfully' : l:swo.' delete faild '
	endif
endfunction

function! DeleteFile(filename)
	let l:del_result = delete(expand(a:filename))
	return l:del_result == 0 ? 1 : 0
endfunction

function! CheckFile(filename)
	&quot; 对于不可以读取的文件，换成glob
	if filereadable(expand(a:filename)) 
		return 1
	else
		return 0
	endif
endfunction

&quot; 调用删除swp,swo文件函数
nnoremap &amp;lt;leader&amp;gt;ds :call DeleteSpaw()&amp;lt;cr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;获取文件名expand(‘%:t’),参考&lt;code class=&quot;highlighter-rouge&quot;&gt;help filename-modifiers&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;文件相关的函数，&lt;code class=&quot;highlighter-rouge&quot;&gt;filereadable(), delete()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;函数内部对参数使用，a:param&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="vim" /><category term="swp" /><category term="swo" /><category term="delete" /><summary type="html">写了一个小函数，来删除vim的swp和swo文件。</summary></entry><entry><title type="html">Magic Regrex In Vimscript</title><link href="http://localhost:4000/Vimscript-Magic-Regrex/" rel="alternate" type="text/html" title="Magic Regrex In Vimscript" /><published>2019-01-31T00:00:00+08:00</published><updated>2019-01-31T00:00:00+08:00</updated><id>http://localhost:4000/Vimscript-Magic-Regrex</id><content type="html" xml:base="http://localhost:4000/Vimscript-Magic-Regrex/">&lt;h1 id=&quot;正则表达式&quot;&gt;正则表达式&lt;/h1&gt;

&lt;h3 id=&quot;magic&quot;&gt;Magic&lt;/h3&gt;
&lt;p&gt;{test&lt;a href=&quot;123&quot;&gt;123&lt;/a&gt;}&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Vim有&lt;strong&gt;四种&lt;/strong&gt;不同的解析正则表达式的模式！！！真让人蒙蔽。。。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="vim" /><category term="vimscript" /><category term="regrex" /><summary type="html">正则表达式</summary></entry><entry><title type="html">Nodejs Async Await</title><link href="http://localhost:4000/nodejs-async-await/" rel="alternate" type="text/html" title="Nodejs Async Await" /><published>2019-01-31T00:00:00+08:00</published><updated>2019-01-31T00:00:00+08:00</updated><id>http://localhost:4000/nodejs-async-await</id><content type="html" xml:base="http://localhost:4000/nodejs-async-await/"></content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Nodejs Promise</title><link href="http://localhost:4000/nodejs-promise/" rel="alternate" type="text/html" title="Nodejs Promise" /><published>2019-01-30T00:00:00+08:00</published><updated>2019-01-30T00:00:00+08:00</updated><id>http://localhost:4000/nodejs-promise</id><content type="html" xml:base="http://localhost:4000/nodejs-promise/"></content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">My nodejs note</title><link href="http://localhost:4000/nodejs-note/" rel="alternate" type="text/html" title="My nodejs note" /><published>2019-01-29T00:00:00+08:00</published><updated>2019-01-29T00:00:00+08:00</updated><id>http://localhost:4000/nodejs-note</id><content type="html" xml:base="http://localhost:4000/nodejs-note/">&lt;p&gt;Nodejs is just a kind of of js..^_^&lt;/p&gt;

&lt;h1 id=&quot;基本语法&quot;&gt;基本语法&lt;/h1&gt;

&lt;p&gt;pass&lt;/p&gt;

&lt;h1 id=&quot;工程相关&quot;&gt;工程相关&lt;/h1&gt;

&lt;h3 id=&quot;模块&quot;&gt;模块&lt;/h3&gt;

&lt;p&gt;在模块中，用require()方法来引入外部模块。用exports对象用于导出当前模块的方法或变量,只有导出的变量或方法才能被其他模块使用。就像是oop中的public。这点和erlang有点像，erlang是声明一个导出列表&lt;code&gt;-export([add/1,...])&lt;/code&gt;
在模块中，module对象，代表自身，exports也是module的一个属性.
在nodejs中，一个文件就是一个模块.(其他编程语言也差不多)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;require()的参数就是模块标识。参数可以是小驼峰命名的字符串(模块名?),
也可以是相对路径，或绝对路径。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;两种模块，Node提供的核心模块(fs,http,path…)，用户编写的称为文件模块。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模块加载，优先从缓存加载，核心模块加载，路径形式的模块，自定义模块(加载最慢，一种特殊的文件模块)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;自定义模块&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  文件内容：
  console.log(module.paths);
  node ./test.js,输出如下:
  [ '/home/wm/code/nodejs/one_night/node_modules',
    '/home/wm/code/nodejs/node_modules',
    '/home/wm/code/node_modules',
    '/home/wm/node_modules',
    '/home/node_modules',
    '/node_modules' ]
  node查找自定义模块的规则：
  当前文件目录的node_modules目录下查找
  父目录的node_modules目录
  ...
  直到根目录下的node_modules目录
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;引用了不同的模块，如果他们有相同的导出方法或属性。后面引用的模块会覆盖先引用的模块&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ./node_modules/demo.js内容:
  hello = function(){
      console.log(&quot;hello world&quot;);
  }
  exports.hello;

  ./node_modules/hi.js内容:
  hello = function(){
      console.log(&quot;hi world&quot;);
  }
  exports.hello;

  ./test.js内容如下:
  require('hi');
  require(&quot;demo&quot;);
  hello(); // 输出 hello world
  console.log(module.paths);
		
  require(&quot;demo&quot;);
  require('hi');
  hello(); // 输出 hi world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;文件扩展名.当标识符没有扩展名时 Node会按.js .json .node的顺序依次补充扩展名，以此尝试&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;目录分析和包&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  在node_modules/目录下的子目录，可以做成一个包，package
  前提是，这个目录下要有一个package.json文件，并且文件能通过JSON.parse()解析出描述对象。
  比如main属性，指定文件名进行定位。
  如果没有package.json文件，node会依次查找index.js index.json index.node

  ./test.js内容如下:
  require(&quot;mypackage&quot;);
  test(&quot;guogu0&quot;); // 输出 myname is guoguo

  在当前./node_modules/下发现了子目录./node_modules/mypackage/
  mypackage/目录下有package.json文件，内容如下
  {
      &quot;name&quot;:&quot;mypack&quot;,
      &quot;version&quot;: &quot;0.0.1&quot;,
      &quot;main&quot;: &quot;./src/bar.js&quot; // 先对package.json文件的路径
  }
  通过main属性可知，这个mypackage包 指定的是 ./node_modules/mypackage/src/bar.js文件
  该bar.js文件内容如下：
  test = function(name) {
      console.log(&quot;myname is &quot;+name);
  }
  exports.test = test;

  所以test.js在require(&quot;mypackage&quot;)的时候，其实是找到了一个目录，也就是一个包。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="nodjs" /><category term="tiny demo" /><summary type="html">Nodejs is just a kind of of js..^_^</summary></entry><entry><title type="html">Execute &amp;amp; normal in Vimscript</title><link href="http://localhost:4000/vimscript-execute-normal/" rel="alternate" type="text/html" title="Execute &amp; normal in Vimscript" /><published>2019-01-28T00:00:00+08:00</published><updated>2019-01-28T00:00:00+08:00</updated><id>http://localhost:4000/vimscript-execute-normal</id><content type="html" xml:base="http://localhost:4000/vimscript-execute-normal/">&lt;h1 id=&quot;execute命令&quot;&gt;Execute命令&lt;/h1&gt;

&lt;p&gt;execute命令，把字符串当作vimscript命令来执行.&lt;/p&gt;

&lt;h4 id=&quot;基本用法&quot;&gt;基本用法&lt;/h4&gt;

&lt;p&gt;:exe[cute] {expr1} ..	
	把{expr1}当作一个Ex命令来执行，并返回结果。多个参数，用空格分隔。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;多个命令可以用| 连起来
:execute '!ls' | echom &quot;theend&quot; 

在execute后面的字符串中可以使用\&amp;lt;esc&amp;gt;这样的方式来使用\e,看上去跟明显
\e	escape &amp;lt;Esc&amp;gt;
\f	formfeed &amp;lt;FF&amp;gt;
\n	newline &amp;lt;NL&amp;gt;
\r	return &amp;lt;CR&amp;gt;
\t	tab &amp;lt;Tab&amp;gt;

当文件名中有特殊字符的时候，要小心了。
:execute &quot;e &quot;.fnameescape(filename) &quot; fnameescape()函数用在vim的命令中
:execute &quot;!ls &quot; . shellescape(filename, 1) &quot; shellescape()函数用在shell命令中

当要执行多行的命令时，用|来 执行得了,|要放在引号之内
:execute 'while i &amp;lt; 5 | echo i | let i = i + 1 | endwhile'

注释,|&quot;之后的是注释
execute &quot;echo 'foo'&quot; | &quot; this is a comment
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;normal命令&quot;&gt;Normal命令&lt;/h1&gt;

&lt;p&gt;normal 命令简单地接受一串键值并当作是在normal模式下输入的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:normal ggdd  &quot;删除第一行
:normal G &quot;一般情况下，这个会把光标移到最后一行。
&quot;但是如果用户设置映射呢?比如nnoremap G dd ,这个时候，就会变成删除了。。。。惊不惊喜？
:normal! G &quot;这样就能确保光标移到最后，即便用户设置了G的映射，映射也不会生效。

所以，在写vim脚本的时候，应该总是用normal!,因为你不确定用户在他的.vimrc文件中做了哪些映射

:normal! /foo&amp;lt;cr&amp;gt; &quot;这样不会起作用 ,这种情况，需要结合execute来进行

:execute &quot;normal! /foo\&amp;lt;cr&amp;gt;&quot; &quot; 这样就可以起到查找foo的作用了

:execute &quot;normal! mqA;\&amp;lt;esc&amp;gt;`q&quot; &quot;在行尾添加一个;然后光标回到原来的位置
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;转义字符&quot;&gt;转义字符&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;string&quot;		string constant		*expr-quote*

Note that double quotes are used.

A string constant accepts these special characters:
\...	three-digit octal number (e.g., &quot;\316&quot;)
\..	two-digit octal number (must be followed by non-digit)
\.	one-digit octal number (must be followed by non-digit)
\x..	byte specified with two hex numbers (e.g., &quot;\x1f&quot;)
\x.	byte specified with one hex number (must be followed by non-hex char)
\X..	same as \x..
\X.	same as \x.
\u....	character specified with up to 4 hex numbers, stored according to the
	current value of 'encoding' (e.g., &quot;\u02a4&quot;)
\U....	same as \u but allows up to 8 hex numbers.
\b	backspace &amp;lt;BS&amp;gt;
\e	escape &amp;lt;Esc&amp;gt;
\f	formfeed &amp;lt;FF&amp;gt;
\n	newline &amp;lt;NL&amp;gt;
\r	return &amp;lt;CR&amp;gt;
\t	tab &amp;lt;Tab&amp;gt;
\\	backslash
\&quot;	double quote
\&amp;lt;xxx&amp;gt;	Special key named &quot;xxx&quot;.  e.g. &quot;\&amp;lt;C-W&amp;gt;&quot; for CTRL-W.  This is for use
	in mappings, the 0x80 byte is escaped.
	To use the double quote character it must be escaped: &quot;&amp;lt;M-\&quot;&amp;gt;&quot;.
	Don't use &amp;lt;Char-xxxx&amp;gt; to get a utf-8 character, use \uxxxx as
	mentioned above.

Note that &quot;\xff&quot; is stored as the byte 255, which may be invalid in some
encodings.  Use &quot;\u00ff&quot; to store character 255 according to the current value
of 'encoding'.

Note that &quot;\000&quot; and &quot;\x00&quot; force the end of the string.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="execute" /><category term="normal" /><category term="vimscript" /><category term="vim" /><summary type="html">Execute命令</summary></entry><entry><title type="html">vimscript regex</title><link href="http://localhost:4000/vimscript-regex/" rel="alternate" type="text/html" title="vimscript regex" /><published>2019-01-28T00:00:00+08:00</published><updated>2019-01-28T00:00:00+08:00</updated><id>http://localhost:4000/vimscript-regex</id><content type="html" xml:base="http://localhost:4000/vimscript-regex/"></content><author><name></name></author><category term="vimscript" /><category term="regex" /><category term="vim" /><summary type="html"></summary></entry></feed>